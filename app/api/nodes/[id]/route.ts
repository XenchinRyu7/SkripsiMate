// API Route: Update and Delete Node Details
import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase';
import { logger } from '@/lib/logger';

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: nodeId } = await params;
    const { searchParams } = new URL(request.url);
    const projectId = searchParams.get('projectId');

    if (!projectId) {
      return NextResponse.json(
        { error: 'Project ID is required' },
        { status: 400 }
      );
    }

    if (!supabaseAdmin) {
      return NextResponse.json(
        { error: 'Supabase admin client not configured' },
        { status: 500 }
      );
    }

    // Get the node to be deleted
    const { data: nodeToDelete, error: fetchError } = await supabaseAdmin
      .from('nodes')
      .select('*')
      .eq('id', nodeId)
      .single();

    if (fetchError || !nodeToDelete) {
      return NextResponse.json(
        { error: 'Node not found' },
        { status: 404 }
      );
    }

    // Cascade delete: find all children (steps/substeps)
    const { data: children, error: childrenError } = await supabaseAdmin
      .from('nodes')
      .select('id')
      .eq('parent_id', nodeId);

    if (childrenError) {
      logger.error('Error fetching children:', childrenError);
    }

    // Delete all children first (recursive cascade)
    if (children && children.length > 0) {
      for (const child of children) {
        // Recursive delete grandchildren (substeps of steps)
        const { data: grandchildren } = await supabaseAdmin
          .from('nodes')
          .select('id')
          .eq('parent_id', child.id);

        if (grandchildren && grandchildren.length > 0) {
          const grandchildIds = grandchildren.map(gc => gc.id);
          await supabaseAdmin
            .from('nodes')
            .delete()
            .in('id', grandchildIds);
        }
      }

      // Delete immediate children
      const childIds = children.map(c => c.id);
      await supabaseAdmin
        .from('nodes')
        .delete()
        .in('id', childIds);
    }

    // Delete the node itself
    logger.debug('🗑️', 'Deleting node:', nodeId);
    const { data: deleteData, error: deleteError, count } = await supabaseAdmin
      .from('nodes')
      .delete()
      .eq('id', nodeId)
      .select();

    logger.debug('📊', 'Delete result:', { 
      deleted: deleteData?.length || 0, 
      count, 
      error: deleteError 
    });

    if (deleteError) {
      logger.error('❌ Delete error:', deleteError);
      return NextResponse.json(
        { 
          error: 'Failed to delete node',
          details: deleteError.message,
          code: deleteError.code 
        },
        { status: 500 }
      );
    }

    if (!deleteData || deleteData.length === 0) {
      logger.warn('⚠️ No rows deleted! Node might not exist or already deleted');
    } else {
      logger.success('Successfully deleted node from DB');
    }

    // Remove edges connected to this node from project metadata
    const { data: project } = await supabaseAdmin
      .from('projects')
      .select('metadata')
      .eq('id', projectId)
      .single();

    if (project) {
      const metadata = (project.metadata as any) || {};
      const customEdges = metadata.customEdges || [];
      const deletedEdges = metadata.deletedEdges || [];

      // Remove edges that reference the deleted node
      const updatedCustomEdges = customEdges.filter((edge: any) => 
        edge.source !== nodeId && edge.target !== nodeId
      );

      // Add auto-generated edges to deletedEdges list
      const autoGeneratedEdgeIds = [
        `e-${nodeId}-*`,
        `e-*-${nodeId}`,
        `e-phase-${nodeId}-*`,
        `e-phase-*-${nodeId}`,
      ];

      await supabaseAdmin
        .from('projects')
        .update({
          metadata: {
            ...metadata,
            customEdges: updatedCustomEdges,
            deletedEdges: [...deletedEdges, ...autoGeneratedEdgeIds],
          },
          updated_at: new Date().toISOString(),
        })
        .eq('id', projectId);
    }

    // Fetch remaining nodes
    const { data: remainingNodes, error: refetchError } = await supabaseAdmin
      .from('nodes')
      .select('*')
      .eq('project_id', projectId)
      .order('order_index', { ascending: true });

    if (refetchError) {
      logger.error('Refetch error:', refetchError);
      return NextResponse.json(
        { error: 'Failed to fetch remaining nodes' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      nodes: remainingNodes,
      message: 'Node and its children deleted successfully',
    });
  } catch (error: any) {
    logger.error('Error deleting node:', error);
    return NextResponse.json(
      { error: error.message || 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: nodeId } = await params;
    const body = await request.json();
    const { title, description, priority, metadata } = body;

    if (!supabaseAdmin) {
      return NextResponse.json(
        { error: 'Supabase admin client not configured' },
        { status: 500 }
      );
    }

    // Get the node being updated
    const { data: node, error: nodeError } = await supabaseAdmin
      .from('nodes')
      .select('*')
      .eq('id', nodeId)
      .single();

    if (nodeError || !node) {
      return NextResponse.json(
        { error: 'Node not found' },
        { status: 404 }
      );
    }

    // Build update object (only include fields that are provided)
    const updateData: any = {
      updated_at: new Date().toISOString(),
    };

    if (title !== undefined) updateData.title = title;
    if (description !== undefined) updateData.description = description;
    if (priority !== undefined) updateData.priority = priority;
    if (metadata !== undefined) updateData.metadata = metadata;

    // Update the node
    const { error: updateError } = await supabaseAdmin
      .from('nodes')
      .update(updateData)
      .eq('id', nodeId);

    if (updateError) {
      logger.error('Update error:', updateError);
      return NextResponse.json(
        { error: 'Failed to update node' },
        { status: 500 }
      );
    }

    // Fetch all updated nodes for this project
    const { data: allNodes, error: fetchError } = await supabaseAdmin
      .from('nodes')
      .select('*')
      .eq('project_id', node.project_id)
      .order('order_index', { ascending: true });

    if (fetchError) {
      logger.error('Fetch error:', fetchError);
      return NextResponse.json(
        { error: 'Failed to fetch updated nodes' },
        { status: 500 }
      );
    }

    // Recalculate estimated time if needed
    await updateProjectEstimatedTime(node.project_id, allNodes);

    return NextResponse.json({
      success: true,
      nodes: allNodes,
      message: 'Node updated successfully',
    });
  } catch (error: any) {
    logger.error('Error updating node:', error);
    return NextResponse.json(
      { error: error.message || 'Internal server error' },
      { status: 500 }
    );
  }
}

// Helper function: Update project estimated time based on all nodes
async function updateProjectEstimatedTime(projectId: string, allNodes: any[]) {
  if (!supabaseAdmin) return;

  // Calculate total estimated time from all nodes
  const nodesWithTime = allNodes.filter(n => {
    const meta = n.metadata as any;
    return meta?.estimatedTime;
  });

  if (nodesWithTime.length === 0) return;

  // Sum up all estimated times (assuming they're in a standard format like "2 weeks", "1 month", etc.)
  // For simplicity, we'll just store the longest time as the project estimate
  // You can make this more sophisticated based on your needs
  
  const timeMap: { [key: string]: number } = {
    'day': 1,
    'days': 1,
    'week': 7,
    'weeks': 7,
    'month': 30,
    'months': 30,
    'year': 365,
    'years': 365,
  };

  let totalDays = 0;
  
  for (const node of nodesWithTime) {
    const meta = node.metadata as any;
    const timeStr = meta.estimatedTime.toLowerCase();
    
    // Parse time string (e.g., "2 weeks", "1 month")
    const match = timeStr.match(/(\d+)\s*(\w+)/);
    if (match) {
      const value = parseInt(match[1]);
      const unit = match[2];
      
      const multiplier = timeMap[unit] || 1;
      totalDays += value * multiplier;
    }
  }

  // Convert total days to human-readable format
  let estimatedTime = '';
  if (totalDays >= 365) {
    const years = Math.round(totalDays / 365);
    estimatedTime = `${years} ${years > 1 ? 'years' : 'year'}`;
  } else if (totalDays >= 30) {
    const months = Math.round(totalDays / 30);
    estimatedTime = `${months} ${months > 1 ? 'months' : 'month'}`;
  } else if (totalDays >= 7) {
    const weeks = Math.round(totalDays / 7);
    estimatedTime = `${weeks} ${weeks > 1 ? 'weeks' : 'week'}`;
  } else {
    estimatedTime = `${totalDays} ${totalDays > 1 ? 'days' : 'day'}`;
  }

  // Get existing metadata
  const { data: project } = await supabaseAdmin
    .from('projects')
    .select('metadata')
    .eq('id', projectId)
    .single();

  const existingMetadata = (project?.metadata as any) || {};

  // Update project metadata with calculated estimated time
  await supabaseAdmin
    .from('projects')
    .update({
      metadata: {
        ...existingMetadata,
        estimatedTime,
        calculatedFromNodes: true,
      },
      updated_at: new Date().toISOString(),
    })
    .eq('id', projectId);
}
